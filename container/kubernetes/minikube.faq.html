<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>4.5.Â FAQ</title><link rel="stylesheet" type="text/css" href="../docbook.css" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><meta name="keywords" content="qmeu,kvm,xen,openvz, docker, coreos,docker-compose, kubernetes,kubeadmin,kubectl, netkiller-devops" /><link rel="home" href="../index.html" title="Netkiller Container æ‰‹æœ­" /><link rel="up" href="minikube.html" title="ç¬¬Â 4Â ç« Â Minikube" /><link rel="prev" href="ch04s04.html" title="4.4.Â Minikube æ¡ˆä¾‹æ¼”ç¤º" /><link rel="next" href="microk8s.html" title="ç¬¬Â 5Â ç« Â microk8s" /></head><body><a xmlns="" href="//www.netkiller.cn/">Home</a> | <a xmlns="" href="//netkiller.github.io/">ç®€ä½“ä¸­æ–‡</a> | <a xmlns="" href="http://netkiller.sourceforge.net/">ç¹ä½“ä¸­æ–‡</a> | <a xmlns="" href="/journal/index.html">æ‚æ–‡</a>
		| <a xmlns="" href="https://github.com/netkiller">Github</a> | <a xmlns="" href="https://zhuanlan.zhihu.com/netkiller">çŸ¥ä¹ä¸“æ </a> | <a xmlns="" href="https://www.facebook.com/bg7nyt">Facebook</a> | <a xmlns="" href="http://cn.linkedin.com/in/netkiller/">Linkedin</a> | <a xmlns="" href="https://www.youtube.com/user/bg7nyt/videos">Youtube</a> | <a xmlns="" href="//www.netkiller.cn/home/donations.html">æ‰“èµ(Donations)</a> | <a xmlns="" href="//www.netkiller.cn/home/about.html">About</a><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">4.5.Â FAQ</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch04s04.html">ä¸Šä¸€é¡µ</a>Â </td><th width="60%" align="center">ç¬¬Â 4Â ç« Â Minikube</th><td width="20%" align="right">Â <a accesskey="n" href="microk8s.html">ä¸‹ä¸€é¡µ</a></td></tr></table><hr /></div><table xmlns=""><tr><td><iframe src="//ghbtns.com/github-btn.html?user=netkiller&amp;repo=netkiller.github.io&amp;type=watch&amp;count=true&amp;size=large" height="30" width="170" frameborder="0" scrolling="0" style="width:170px; height: 30px;" allowTransparency="true"></iframe></td><td><iframe src="//ghbtns.com/github-btn.html?user=netkiller&amp;repo=netkiller.github.io&amp;type=fork&amp;count=true&amp;size=large" height="30" width="170" frameborder="0" scrolling="0" style="width:170px; height: 30px;" allowTransparency="true"></iframe></td><td><iframe src="//ghbtns.com/github-btn.html?user=netkiller&amp;type=follow&amp;count=true&amp;size=large" height="30" width="240" frameborder="0" scrolling="0" style="width:240px; height: 30px;" allowTransparency="true"></iframe></td><td></td><td><a href="https://zhuanlan.zhihu.com/netkiller"><img src="/images/logo/zhihu-card-default.svg" height="25" /></a></td><td valign="middle"><a href="https://zhuanlan.zhihu.com/netkiller">çŸ¥ä¹ä¸“æ </a></td><td></td><td></td><td></td><td></td></tr></table><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="minikube.faq"></a>4.5.Â FAQ</h3></div></div></div>
		
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id963"></a>4.5.1.Â This computer doesn't have VT-X/AMD-v enabled. Enabling it in the BIOS is mandatory</h4></div></div></div>
			
			<p>æ£€æŸ¥ä¸€ä¸‹ BIOS æ˜¯å¦å¼€å¯ VT-X/AMD-v</p>
			<p>å¦‚æœåœ¨è™šæ‹Ÿæœºå®‰è£… Minikube ä¹Ÿä¼šé‡åˆ°è¿™ä¸ªé—®é¢˜ã€‚ å¯ä»¥ä½¿ç”¨ --vm-driver=none å‚æ•°å¯åŠ¨ã€‚</p>
			<pre class="screen">
			
neo@ubuntu:~$ sudo minikube start --vm-driver=none
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id964"></a>4.5.2.Â ERROR FileContent--proc-sys-net-bridge-bridge-nf-call-iptables</h4></div></div></div>
			
			<p>è§£å†³æ–¹æ³•</p>
			<pre class="screen">
			
echo "1" &gt; /proc/sys/net/bridge/bridge-nf-call-iptables
			
			</pre>
			<p>ç„¶ååœ¨ minikube start</p>
		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id965"></a>4.5.3.Â ERROR ImagePull</h4></div></div></div>
			
			<p>[ERROR ImagePull]: failed to pull image k8s.gcr.io/pause:3.1: output: 3.1: Pulling from pause
				Get https://k8s.gcr.io/v2/pause/manifests/sha256:59eec8837a4d942cc19a52b8c09ea75121acc38114a2c68b98983ce9356b8610: net/http: TLS handshake timeout
			</p>
			<p>æ›´æ¢é•œåƒå†é‡è¯•</p>
			<pre class="screen">
			
[root@localhost ~]# minikube start --vm-driver=none --registry-mirror=https://registry.docker-cn.com			
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id966"></a>4.5.4.Â è¯ä¹¦å·²å­˜åœ¨é”™è¯¯</h4></div></div></div>
			
			<p>å¯åŠ¨æç¤ºå¦‚ä¸‹é”™è¯¯ï¼Œä¸€èˆ¬å‡ºç°è¿™ç§é”™è¯¯æ˜¯å› ä¸º minikube stop, minikube delete åå†é‡å¯ minikube start</p>
			<pre class="screen">
			
error execution phase kubeconfig/admin: a kubeconfig file "/etc/kubernetes/admin.conf" exists already but has got the wrong CA cert	
error execution phase kubeconfig/kubelet: a kubeconfig file "/etc/kubernetes/kubelet.conf" exists already but has got the wrong CA cert
error execution phase kubeconfig/controller-manager: a kubeconfig file "/etc/kubernetes/controller-manager.conf" exists already but has got the wrong CA cert
error execution phase kubeconfig/scheduler: a kubeconfig file "/etc/kubernetes/scheduler.conf" exists already but has got the wrong CA cert
			
			</pre>
			<p>è§£å†³æ–¹æ³•</p>
			<pre class="screen">
			
[root@localhost ~]# mv /etc/kubernetes/admin.conf /etc/kubernetes/admin.conf.backup
[root@localhost ~]# mv /etc/kubernetes/kubelet.conf /etc/kubernetes/kubelet.conf.backup
[root@localhost ~]# mv /etc/kubernetes/controller-manager.conf /etc/kubernetes/controller-manager.conf.backup
[root@localhost ~]# mv /etc/kubernetes/scheduler.conf /etc/kubernetes/scheduler.conf.backup
			
			</pre>
			<p>ç°åœ¨å¯åŠ¨ minikube start ä¸ä¼šå†å‡ºé”™</p>
			<pre class="screen">
			
[root@localhost ~]# minikube start --vm-driver=none
Starting local Kubernetes v1.13.2 cluster...
Starting VM...
Getting VM IP address...
Moving files into cluster...
Setting up certs...
Connecting to cluster...
Setting up kubeconfig...
Stopping extra container runtimes...
Starting cluster components...
Verifying kubelet health ...
Verifying apiserver health ...
Kubectl is now configured to use the cluster.
===================
WARNING: IT IS RECOMMENDED NOT TO RUN THE NONE DRIVER ON PERSONAL WORKSTATIONS
	The 'none' driver will run an insecure kubernetes apiserver as root that may leave the host vulnerable to CSRF attacks

When using the none driver, the kubectl config and credentials generated will be root owned and will appear in the root home directory.
You will need to move the files to the appropriate location and then set the correct permissions.  An example of this is below:

	sudo mv /root/.kube $HOME/.kube # this will write over any previous configuration
	sudo chown -R $USER $HOME/.kube
	sudo chgrp -R $USER $HOME/.kube

	sudo mv /root/.minikube $HOME/.minikube # this will write over any previous configuration
	sudo chown -R $USER $HOME/.minikube
	sudo chgrp -R $USER $HOME/.minikube

This can also be done automatically by setting the env var CHANGE_MINIKUBE_NONE_USER=true
Loading cached images from config file.


Everything looks great. Please enjoy minikube!
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id967"></a>4.5.5.Â http: server gave HTTP response to HTTPS client</h4></div></div></div>
			
			<p>é—®é¢˜åŸå› ï¼Œä½¿ç”¨ç§æœ‰ registry ç”±äºæ²¡æœ‰ HTTPS å¯¼è‡´ kubectl ä½¿ç”¨ https å»è®¿é—®ç§æœ‰ registry.</p>
			<pre class="screen">
			
Failed to pull image "192.168.3.85:5000/netkiller/config:latest": rpc error: code = Unknown desc = Error response from daemon: Get https://192.168.3.85:5000/v2/: http: server gave HTTP response to HTTPS client			
			
			</pre>
			<p>minikube å¹¶ä¸ä¼šä½¿ç”¨ docker é…ç½®æ–‡ä»¶ä¸­çš„ insecure-registry é…ç½®é¡¹</p>
			<p>è§£å†³åŠæ³•</p>
			<pre class="screen">
					
minikube start --insecure-registry=127.0.0.1:5000		
			
			</pre>
			<p>æˆ–æŒ‡å®šç½‘æ®µ</p>
			<pre class="screen">
			
minikube start --insecure-registry "10.0.0.0/24"			
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id968"></a>4.5.6.Â provided port is not in the valid range. The range of valid ports is 30000-32767</h4></div></div></div>
			
			<pre class="screen">
			
iMac:kubernetes neo$ kubectl create -f redis/redis.yml 
configmap/redis-config created
deployment.apps/redis created
The Service "redis" is invalid: spec.ports[0].nodePort: Invalid value: 6379: provided port is not in the valid range. The range of valid ports is 30000-32767			
			
			</pre>
			<p>ç¼–è¾‘kube-apiserver.yamlæ–‡ä»¶</p>
			<pre class="screen">
			
$ minikube ssh
$ sudo vi /etc/kubernetes/manifests/kube-apiserver.yaml
			
			</pre>
			<p>å¢åŠ kube-apiserverçš„å¯åŠ¨é…ç½®é¡¹</p>
			<pre class="screen">
			
--service-node-port-range=1024-65535
			
			</pre>
			<p></p>
			<pre class="screen">
			
$ sudo cat /etc/kubernetes/manifests/kube-apiserver.yaml
apiVersion: v1
kind: Pod
metadata:
  annotations:
    kubeadm.kubernetes.io/kube-apiserver.advertise-address.endpoint: 192.168.64.5:8443
  creationTimestamp: null
  labels:
    component: kube-apiserver
    tier: control-plane
  name: kube-apiserver
  namespace: kube-system
spec:
  containers:
  - command:
    - kube-apiserver
    - --advertise-address=192.168.64.5
    - --allow-privileged=true
    - --authorization-mode=Node,RBAC
    - --client-ca-file=/var/lib/minikube/certs/ca.crt
    - --enable-admission-plugins=NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,NodeRestriction,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota
    - --enable-bootstrap-token-auth=true
    - --etcd-cafile=/var/lib/minikube/certs/etcd/ca.crt
    - --etcd-certfile=/var/lib/minikube/certs/apiserver-etcd-client.crt
    - --etcd-keyfile=/var/lib/minikube/certs/apiserver-etcd-client.key
    - --etcd-servers=https://127.0.0.1:2379
    - --insecure-port=0
    - --kubelet-client-certificate=/var/lib/minikube/certs/apiserver-kubelet-client.crt
    - --kubelet-client-key=/var/lib/minikube/certs/apiserver-kubelet-client.key
    - --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname
    - --proxy-client-cert-file=/var/lib/minikube/certs/front-proxy-client.crt
    - --proxy-client-key-file=/var/lib/minikube/certs/front-proxy-client.key
    - --requestheader-allowed-names=front-proxy-client
    - --requestheader-client-ca-file=/var/lib/minikube/certs/front-proxy-ca.crt
    - --requestheader-extra-headers-prefix=X-Remote-Extra-
    - --requestheader-group-headers=X-Remote-Group
    - --requestheader-username-headers=X-Remote-User
    - --secure-port=8443
    - --service-account-key-file=/var/lib/minikube/certs/sa.pub
    - --service-cluster-ip-range=10.10.0.0/24
    - --service-node-port-range=1024-65535
    - --tls-cert-file=/var/lib/minikube/certs/apiserver.crt
    - --tls-private-key-file=/var/lib/minikube/certs/apiserver.key
    image: registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver:v1.19.2
    imagePullPolicy: IfNotPresent
    livenessProbe:
      failureThreshold: 8
      httpGet:
        host: 192.168.64.5
        path: /livez
        port: 8443
        scheme: HTTPS
      initialDelaySeconds: 10
      periodSeconds: 10
      timeoutSeconds: 15
    name: kube-apiserver
    readinessProbe:
      failureThreshold: 3
      httpGet:
        host: 192.168.64.5
        path: /readyz
        port: 8443
        scheme: HTTPS
      periodSeconds: 1
      timeoutSeconds: 15
    resources:
      requests:
        cpu: 250m
    startupProbe:
      failureThreshold: 24
      httpGet:
        host: 192.168.64.5
        path: /livez
        port: 8443
        scheme: HTTPS
      initialDelaySeconds: 10
      periodSeconds: 10
      timeoutSeconds: 15
    volumeMounts:
    - mountPath: /etc/ssl/certs
      name: ca-certs
      readOnly: true
    - mountPath: /var/lib/minikube/certs
      name: k8s-certs
      readOnly: true
    - mountPath: /usr/share/ca-certificates
      name: usr-share-ca-certificates
      readOnly: true
  hostNetwork: true
  priorityClassName: system-node-critical
  volumes:
  - hostPath:
      path: /etc/ssl/certs
      type: DirectoryOrCreate
    name: ca-certs
  - hostPath:
      path: /var/lib/minikube/certs
      type: DirectoryOrCreate
    name: k8s-certs
  - hostPath:
      path: /usr/share/ca-certificates
      type: DirectoryOrCreate
    name: usr-share-ca-certificates
status: {}			
			
			</pre>
			<p></p>
			<pre class="screen">
			
sudo systemctl restart kubelet			
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id969"></a>4.5.7.Â Exiting due to MK_ENABLE: run callbacks: running callbacks: [verifying registry addon pods : timed out waiting for the condition: timed out waiting for the condition]</h4></div></div></div>
			
			<pre class="screen">
			
iMac:~ neo$ minikube addons enable registry
ğŸ”  Verifying registry addon...

âŒ  Exiting due to MK_ENABLE: run callbacks: running callbacks: [verifying registry addon pods : timed out waiting for the condition: timed out waiting for the condition]

ğŸ˜¿  If the above advice does not help, please let us know: 
ğŸ‘‰  https://github.com/kubernetes/minikube/issues/new/choose			
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id970"></a>4.5.8.Â  Exiting due to SVC_URL_TIMEOUT: http://127.0.0.1:11068/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/ is not accessible: Temporary Error: unexpected response code: 503</h4></div></div></div>
			
			<pre class="screen">
			
minikube dashboard --alsologtostderr -v=1
			
			</pre>
			<p></p>
			<pre class="screen">
			
[docker@localhost ~]$ kubectl get pods --all-namespaces | grep dashboard
kubernetes-dashboard   dashboard-metrics-scraper-6f7955cd98-xjzkq   0/1     ImagePullBackOff    0          11d
kubernetes-dashboard   kubernetes-dashboard-7bf64fd654-ckr7v        0/1     ImagePullBackOff    0          11d			
			
			</pre>
			<p></p>
			<pre class="screen">
			
[docker@localhost ~]$ kubectl logs --namespace=kubernetes-dashboard kubernetes-dashboard-7bf64fd654-ckr7v
Error from server (BadRequest): container "kubernetes-dashboard" in pod "kubernetes-dashboard-7bf64fd654-ckr7v" is waiting to start: trying and failing to pull image			
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id971"></a>4.5.9.Â Mac minikube ip ä¸é€šï¼Œingress ä¸å·¥ä½œ</h4></div></div></div>
			
			<pre class="screen">
			
minikube start --image-mirror-country=cn --insecure-registry="registry.netkiller.cn" --cache-images=true			
			
			</pre>
			<pre class="screen">
			
Neo-iMac:~ neo$ kubectl get pods -n ingress-nginx
NAME                                        READY   STATUS      RESTARTS   AGE
ingress-nginx-admission-create--1-qpckk     0/1     Completed   0          18h
ingress-nginx-admission-patch--1-5x94l      0/1     Completed   0          18h
ingress-nginx-controller-78d858bdc7-nrszs   1/1     Running     1          18h

Neo-iMac:~ neo$ kubectl create deployment web --image=nginx:latest
deployment.apps/web created

Neo-iMac:~ neo$ kubectl expose deployment web --type=NodePort --port=80
service/web exposed

Neo-iMac:~ neo$ kubectl get service web
NAME   TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
web    NodePort   10.109.55.204   &lt;none&gt;        8080:30857/TCP   19s

Neo-iMac:~ neo$ minikube service web --url
ğŸƒ  Starting tunnel for service web.
|-----------|------|-------------|------------------------|
| NAMESPACE | NAME | TARGET PORT |          URL           |
|-----------|------|-------------|------------------------|
| default   | web  |             | http://127.0.0.1:62956 |
|-----------|------|-------------|------------------------|
http://127.0.0.1:62956
â—  Because you are using a Docker driver on darwin, the terminal needs to be open to run it.			
			
			</pre>
			<p>ingress.yaml</p>
			<pre class="screen">
			
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: nginx
  annotations:
    kubernetes.io/ingress.class: nginx  
spec:
  rules:
    - host: www.netkiller.cn
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: web
                port:
                  number: 80			
			
			</pre>
			<p>http://www.netkiller.cn æ— æ³•è®¿é—®ï¼Œè§£å†³æ–¹æ¡ˆ minikube tunnel</p>
			<pre class="screen">
			
Neo-iMac:~ neo$ minikube tunnel
â—  The service/ingress example-ingress requires privileged ports to be exposed: [80 443]
ğŸ”‘  sudo permission will be asked for it.
ğŸƒ  Starting tunnel for service example-ingress.
Password:			
			
			</pre>
			<p>å¦‚æœæ³¨æ„è§‚å¯Ÿï¼Œåœ¨å¯åŠ¨çš„æ—¶å€™ç³»ç»Ÿå·²ç»æç¤ºï¼šAfter the addon is enabled, please run "minikube tunnel" and your ingress resources would be available at "127.0.0.1"</p>
			<pre class="screen">
			
Neo-iMac:nginx neo$ minikube start --image-mirror-country=cn --insecure-registry="registry.netkiller.cn" --cache-images=true
ğŸ˜„  minikube v1.24.0 on Darwin 12.0.1
âœ¨  Using the docker driver based on existing profile
ğŸ‘  Starting control plane node minikube in cluster minikube
ğŸšœ  Pulling base image ...
ğŸ”„  Restarting existing docker container for "minikube" ...
ğŸ³  Preparing Kubernetes v1.22.3 on Docker 20.10.8 ...
ğŸ”  Verifying Kubernetes components...
ğŸ’¡  After the addon is enabled, please run "minikube tunnel" and your ingress resources would be available at "127.0.0.1"
    â–ª Using image registry.cn-hangzhou.aliyuncs.com/google_containers/dashboard:v2.3.1
    â–ª Using image registry.cn-hangzhou.aliyuncs.com/google_containers/storage-provisioner:v5
    â–ª Using image registry.cn-hangzhou.aliyuncs.com/google_containers/nginx-ingress-controller:v1.0.4
    â–ª Using image registry.cn-hangzhou.aliyuncs.com/google_containers/metrics-scraper:v1.0.7
    â–ª Using image registry.cn-hangzhou.aliyuncs.com/google_containers/kube-webhook-certgen:v1.1.1
    â–ª Using image registry.cn-hangzhou.aliyuncs.com/google_containers/kube-webhook-certgen:v1.1.1
ğŸ”  Verifying ingress addon...
ğŸŒŸ  Enabled addons: dashboard, storage-provisioner, default-storageclass, ingress
ğŸ„  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by default			
			
			</pre>
		</div>
	</div><script xmlns="" type="text/javascript" id="clustrmaps" src="//cdn.clustrmaps.com/map_v2.js?u=r5HG&amp;d=9mi5r_kkDC8uxG8HuY3p4-2qgeeVypAK9vMD-2P6BYM"></script><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch04s04.html">ä¸Šä¸€é¡µ</a>Â </td><td width="20%" align="center"><a accesskey="u" href="minikube.html">ä¸Šä¸€çº§</a></td><td width="40%" align="right">Â <a accesskey="n" href="microk8s.html">ä¸‹ä¸€é¡µ</a></td></tr><tr><td width="40%" align="left" valign="top">4.4.Â Minikube æ¡ˆä¾‹æ¼”ç¤ºÂ </td><td width="20%" align="center"><a accesskey="h" href="../index.html">èµ·å§‹é¡µ</a></td><td width="40%" align="right" valign="top">Â ç¬¬Â 5Â ç« Â microk8s</td></tr></table></div><script xmlns="">
			(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

			ga('create', 'UA-11694057-1', 'auto');
			ga('send', 'pageview');

		</script><script xmlns="" async="async">
			var _hmt = _hmt || [];
			(function() {
			var hm = document.createElement("script");
			hm.src = "https://hm.baidu.com/hm.js?93967759a51cda79e49bf4e34d0b0f2c";
			var s = document.getElementsByTagName("script")[0];
			s.parentNode.insertBefore(hm, s);
			})();
</script><script xmlns="" async="async">
			(function(){
			var bp = document.createElement('script');
			var curProtocol = window.location.protocol.split(':')[0];
			if (curProtocol === 'https') {
			bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
			}
			else {
			bp.src = 'http://push.zhanzhang.baidu.com/push.js';
			}
			var s = document.getElementsByTagName("script")[0];
			s.parentNode.insertBefore(bp, s);
			})();
</script></body></html>