<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>21.2. 音频处理</title><link rel="stylesheet" type="text/css" href="../docbook.css" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><meta name="keywords" content="php,pear,pecl,phar, python, , " /><link rel="home" href="../index.html" title="Netkiller Python 手札" /><link rel="up" href="../av.html" title="第 21 章 音频和视频" /><link rel="prev" href="../av.html" title="第 21 章 音频和视频" /><link rel="next" href="../moviepy/index.html" title="21.3. MoviePy" /></head><body><a xmlns="" href="//www.netkiller.cn/">Home</a> | <a xmlns="" href="//netkiller.github.io/">简体中文</a> | <a xmlns="" href="http://netkiller.sourceforge.net/">繁体中文</a> | <a xmlns="" href="/journal/index.html">杂文</a>
		| <a xmlns="" href="https://github.com/netkiller">Github</a> | <a xmlns="" href="https://zhuanlan.zhihu.com/netkiller">知乎专栏</a> | <a xmlns="" href="https://www.facebook.com/bg7nyt">Facebook</a> | <a xmlns="" href="http://cn.linkedin.com/in/netkiller/">Linkedin</a> | <a xmlns="" href="https://www.youtube.com/user/bg7nyt/videos">Youtube</a> | <a xmlns="" href="//www.netkiller.cn/home/donations.html">打赏(Donations)</a> | <a xmlns="" href="//www.netkiller.cn/home/about.html">About</a><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">21.2. 音频处理</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="../av.html">上一页</a> </td><th width="60%" align="center">第 21 章 音频和视频</th><td width="20%" align="right"> <a accesskey="n" href="../moviepy/index.html">下一页</a></td></tr></table><hr /></div><table xmlns=""><tr><td><iframe src="//ghbtns.com/github-btn.html?user=netkiller&amp;repo=netkiller.github.io&amp;type=watch&amp;count=true&amp;size=large" height="30" width="170" frameborder="0" scrolling="0" style="width:170px; height: 30px;" allowTransparency="true"></iframe></td><td><iframe src="//ghbtns.com/github-btn.html?user=netkiller&amp;repo=netkiller.github.io&amp;type=fork&amp;count=true&amp;size=large" height="30" width="170" frameborder="0" scrolling="0" style="width:170px; height: 30px;" allowTransparency="true"></iframe></td><td><iframe src="//ghbtns.com/github-btn.html?user=netkiller&amp;type=follow&amp;count=true&amp;size=large" height="30" width="240" frameborder="0" scrolling="0" style="width:240px; height: 30px;" allowTransparency="true"></iframe></td><td></td><td><a href="https://zhuanlan.zhihu.com/netkiller"><img src="/images/logo/zhihu-card-default.svg" height="25" /></a></td><td valign="middle"><a href="https://zhuanlan.zhihu.com/netkiller">知乎专栏</a></td><td></td><td></td><td></td><td></td></tr></table><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="index"></a>21.2. 音频处理</h2></div></div></div>
	
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id1280"></a>21.2.1. 录音 WAV 文件</h3></div></div></div>
		
		<pre class="programlisting">
		
#! /usr/scripts/env python3
# -*- coding: UTF-8 -*-
##############################################
# Home	: http://netkiller.github.io
# Author: Neo &lt;netkiller@msn.com&gt;
# Data: 2026-02-03
# Description: wav 文件录音
##############################################		
import datetime
import wave

import pyaudio

FORMAT = pyaudio.paInt16
CHANNELS = 1
RATE = 16000
FRAMES_PER_BUFFER = 2048

if __name__ == '__main__':
    filename = f"录音：time-{RATE}-" + str(datetime.datetime.now().strftime("%H%M%S")) + ".wav"
    print(filename)

    p = pyaudio.PyAudio()
    stream = p.open(format=FORMAT, channels=CHANNELS, rate=RATE, input=True, frames_per_buffer=FRAMES_PER_BUFFER)

    isLoop = True
    buffer = []

    try:
        while (isLoop):
            raw_data = stream.read(FRAMES_PER_BUFFER)
            if len(raw_data) &gt; 0:
                buffer.append(raw_data)

    except KeyboardInterrupt:
        isLoop = False
        print("停止录音")
    except Exception as e:
        print(f"录音出错：{e}")
    finally:
        stream.stop_stream()
        stream.close()
        p.terminate()

        wf = wave.open(filename, 'wb')
        wf.setnchannels(CHANNELS)
        wf.setsampwidth(p.get_sample_size(FORMAT))
        wf.setframerate(RATE)
        wf.writeframes(b''.join(buffer))
        wf.close()
		
		
		</pre>
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id1281"></a>21.2.2. 录音 mp3 文件</h3></div></div></div>
		
		<pre class="programlisting">
		
#! /usr/scripts/env python3
# -*- coding: UTF-8 -*-
##############################################
# Home	: http://netkiller.github.io
# Author: Neo &lt;netkiller@msn.com&gt;
# Data: 2026-02-03
# Description: mp3 文件录音
##############################################
import datetime
import io

import pyaudio
from pydub import AudioSegment

FORMAT = pyaudio.paInt16
CHANNELS = 1
RATE = 16000
FRAMES_PER_BUFFER = 2048

if __name__ == '__main__':
    filename = f"test-" + str(datetime.datetime.now().strftime("%H%M%S")) + ".mp3"
    print(f"录音：{filename}")

    p = pyaudio.PyAudio()
    stream = p.open(format=FORMAT, channels=CHANNELS, rate=RATE, input=True, frames_per_buffer=FRAMES_PER_BUFFER)

    isLoop = True
    pcm_buffer = []

    try:
        while (isLoop):
            raw_data = stream.read(FRAMES_PER_BUFFER)
            if len(raw_data) &gt; 0:
                pcm_buffer.append(raw_data)

    except KeyboardInterrupt:
        isLoop = False
        print("停止录音")
    except Exception as e:
        print(f"录音出错：{e}")
    finally:
        stream.stop_stream()
        stream.close()
        p.terminate()

        # 内存里加载PCM数据流到 AudioSegment
        audio = AudioSegment.from_raw(io.BytesIO(b''.join(pcm_buffer)),
                                      sample_width=2,
                                      channels=CHANNELS,
                                      frame_rate=RATE
                                      )

        mp3_buffer = io.BytesIO()
        mp3_buffer.seek(0)
        audio.export(mp3_buffer, 'mp3')

        mp3_data = mp3_buffer.getbuffer().tobytes()

        file = open(filename, 'wb')
        file.write(mp3_data)
        file.close()
		
		
		</pre>
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id1282"></a>21.2.3. Opus 文件录音</h3></div></div></div>
		
		<pre class="programlisting">
		
#! /usr/scripts/env python3
# -*- coding: UTF-8 -*-
##############################################
# Home	: http://netkiller.github.io
# Author: Neo &lt;netkiller@msn.com&gt;
# Data: 2026-02-03
# Description: opus 文件录音
##############################################
import datetime
import io

import pyaudio
from pydub import AudioSegment

FORMAT = pyaudio.paInt16
CHANNELS = 1
RATE = 16000
FRAMES_PER_BUFFER = 2048

if __name__ == '__main__':
    filename = f"test-" + str(datetime.datetime.now().strftime("%H%M%S")) + ".opus"
    print(f"录音：{filename}")

    p = pyaudio.PyAudio()
    stream = p.open(format=FORMAT, channels=CHANNELS, rate=RATE, input=True, frames_per_buffer=FRAMES_PER_BUFFER)

    isLoop = True
    pcm_buffer = []

    try:
        while (isLoop):
            raw_data = stream.read(FRAMES_PER_BUFFER)
            if len(raw_data) &gt; 0:
                pcm_buffer.append(raw_data)

    except KeyboardInterrupt:
        isLoop = False
        print("停止录音")
    except Exception as e:
        print(f"录音出错：{e}")
    finally:
        stream.stop_stream()
        stream.close()
        p.terminate()

        # 内存里加载PCM数据流到 AudioSegment
        audio = AudioSegment.from_raw(io.BytesIO(b''.join(pcm_buffer)),
                                      sample_width=2,
                                      channels=CHANNELS,
                                      frame_rate=RATE
                                      )

        mp3_buffer = io.BytesIO()
        mp3_buffer.seek(0)
        audio.export(mp3_buffer, 'opus')

        mp3_data = mp3_buffer.getbuffer().tobytes()

        file = open(filename, 'wb')
        file.write(mp3_data)
        file.close()
		
		
		</pre>
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id1286"></a>21.2.4. 网络播放音频 PCM 流</h3></div></div></div>
		
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id1283"></a>21.2.4.1. 安装 </h4></div></div></div>
			
			<pre class="screen">
			
# dnf install portaudio-devel
# pip install pyaudio		
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id1284"></a>21.2.4.2. 服务端</h4></div></div></div>
			
			<pre class="programlisting">
			
#!/usr/bin/env python

import pyaudio
import socket
import select

FORMAT = pyaudio.paInt16
CHANNELS = 1
RATE = 44100
CHUNK = 4096

audio = pyaudio.PyAudio()

serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
serversocket.bind(('', 4444))
serversocket.listen(5)


def callback(in_data, frame_count, time_info, status):
    for s in read_list[1:]:
        s.send(in_data)
    return (None, pyaudio.paContinue)


# start Recording
stream = audio.open(format=FORMAT, channels=CHANNELS, rate=RATE, input=True, frames_per_buffer=CHUNK, stream_callback=callback)
# stream.start_stream()

read_list = [serversocket]
print "recording..."

try:
    while True:
        readable, writable, errored = select.select(read_list, [], [])
        for s in readable:
            if s is serversocket:
                (clientsocket, address) = serversocket.accept()
                read_list.append(clientsocket)
                print "Connection from", address
            else:
                data = s.recv(1024)
                if not data:
                    read_list.remove(s)
except KeyboardInterrupt:
    pass


print "finished recording"

serversocket.close()
# stop Recording
stream.stop_stream()
stream.close()
audio.terminate()			
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id1285"></a>21.2.4.3. 客户端</h4></div></div></div>
			
			<pre class="programlisting">
			
#!/usr/bin/env python

import pyaudio
import socket
import sys

FORMAT = pyaudio.paInt16
CHANNELS = 1
RATE = 44100
CHUNK = 4096

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((sys.argv[1], int(sys.argv[2])))
audio = pyaudio.PyAudio()
stream = audio.open(format=FORMAT, channels=CHANNELS, rate=RATE, output=True, frames_per_buffer=CHUNK)

try:
    while True:
        data = s.recv(CHUNK)
        stream.write(data)
except KeyboardInterrupt:
    pass

print('Shutting down')
s.close()
stream.close()
audio.terminate()		
			
			</pre>
		</div>
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id1289"></a>21.2.5. 网络传输音频 Opus</h3></div></div></div>
		
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id1287"></a>21.2.5.1. 接收端</h4></div></div></div>
			
			<pre class="programlisting">
			
#! /usr/scripts/env python3
# -*- coding: UTF-8 -*-
##############################################
# Home	: http://netkiller.github.io
# Author: Neo &lt;netkiller@msn.com&gt;
# Data: 2026-02-05
# Description: Opus UDP 接收端
##############################################
import socket
import struct

import opuslib_next
import pyaudio

# 音频配置（必须和发送端完全一致）
SAMPLING_RATE = 16000
CHANNELS = 1
SAMPLE_WIDTH = 2
FRAME_DURATION = 20
FRAMES_PER_BUFFER = int(SAMPLING_RATE * FRAME_DURATION / 1000)

# UDP配置
UDP_IP = "0.0.0.0"  # 监听所有网卡
UDP_PORT = 5005
BUFFER_SIZE = 4096  # UDP接收缓冲区


def main():
    # 1. 初始化UDP socket
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind((UDP_IP, UDP_PORT))

    # 2. 初始化Opus解码器
    decoder = opuslib_next.Decoder(
        fs=SAMPLING_RATE,
        channels=CHANNELS
    )

    # 3. 初始化PyAudio
    p = pyaudio.PyAudio()

    # 4. 打开音频播放流
    stream = p.open(
        format=p.get_format_from_width(SAMPLE_WIDTH),
        channels=CHANNELS,
        rate=SAMPLING_RATE,
        output=True,
        frames_per_buffer=FRAMES_PER_BUFFER
    )

    print(f"开始监听UDP {UDP_IP}:{UDP_PORT}... (按Ctrl+C停止)")
    try:
        while True:
            # 接收UDP数据
            data, addr = sock.recvfrom(BUFFER_SIZE)

            # 解析数据：前4字节是opus数据长度
            opus_len = struct.unpack('!I', data[:4])[0]
            opus_data = data[4:]

            # 验证数据长度（防止传输异常）
            if len(opus_data) != opus_len:
                print(f"警告：接收到的数据长度异常，跳过该帧")
                continue

            # 将Opus解码为PCM
            pcm_data = decoder.decode(opus_data, FRAMES_PER_BUFFER)

            # 播放PCM音频
            stream.write(pcm_data)

    except KeyboardInterrupt:
        print("\n停止接收...")
    finally:
        # 清理资源
        stream.stop_stream()
        stream.close()
        p.terminate()
        sock.close()


if __name__ == "__main__":
    main()
			
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="id1288"></a>21.2.5.2. 发送端</h4></div></div></div>
			
			<pre class="programlisting">
			
#! /usr/scripts/env python3
# -*- coding: UTF-8 -*-
##############################################
# Home	: http://netkiller.github.io
# Author: Neo &lt;netkiller@msn.com&gt;
# Data: 2026-02-05
# Description: Opus UDP 发送端
##############################################			
import socket
import struct

import opuslib_next
import pyaudio

# 音频配置参数
SAMPLING_RATE = 16000  # 16kHz 采样率
CHANNELS = 1  # 单声道
SAMPLE_WIDTH = 2  # 16bit = 2字节
FRAME_DURATION = 20  # 20ms 帧长 (Opus推荐)
FRAMES_PER_BUFFER = int(SAMPLING_RATE * FRAME_DURATION / 1000)  # 每帧采样数: 16000*20/1000=320

# UDP配置
UDP_IP = "127.0.0.1"  # 接收端IP，实际使用时改为对方IP
UDP_PORT = 5005


def main():
    # 1. 初始化UDP socket
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

    # 2. 初始化Opus编码器
    encoder = opuslib_next.Encoder(
        fs=SAMPLING_RATE,
        channels=CHANNELS,
        application=opuslib_next.APPLICATION_VOIP  # 针对语音优化
    )
    # 设置编码比特率 (语音推荐8000-48000)
    encoder.bitrate = 16000

    # 3. 初始化PyAudio
    p = pyaudio.PyAudio()

    # 4. 打开麦克风音频流
    stream = p.open(
        format=p.get_format_from_width(SAMPLE_WIDTH),
        channels=CHANNELS,
        rate=SAMPLING_RATE,
        input=True,
        frames_per_buffer=FRAMES_PER_BUFFER
    )

    print("开始录音并发送音频... (按Ctrl+C停止)")
    try:
        while True:
            # 读取麦克风的PCM音频数据
            pcm_data = stream.read(FRAMES_PER_BUFFER, exception_on_overflow=False)

            # 将PCM编码为Opus
            opus_data = encoder.encode(pcm_data, FRAMES_PER_BUFFER)

            # 发送前先打包数据长度（解决UDP粘包/拆包问题）
            # 用4字节存储数据长度，再拼接opus数据
            data_to_send = struct.pack('!I', len(opus_data)) + opus_data

            # 通过UDP发送
            sock.sendto(data_to_send, (UDP_IP, UDP_PORT))

    except KeyboardInterrupt:
        print("\n停止发送...")
    finally:
        # 清理资源
        stream.stop_stream()
        stream.close()
        p.terminate()
        sock.close()


if __name__ == "__main__":
    main()

			
			</pre>
		</div>
	</div>
</div><script xmlns="" type="text/javascript" id="clustrmaps" src="//cdn.clustrmaps.com/map_v2.js?u=r5HG&amp;d=9mi5r_kkDC8uxG8HuY3p4-2qgeeVypAK9vMD-2P6BYM"></script><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="../av.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="../av.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="../moviepy/index.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">第 21 章 音频和视频 </td><td width="20%" align="center"><a accesskey="h" href="../index.html">起始页</a></td><td width="40%" align="right" valign="top"> 21.3. MoviePy</td></tr></table></div><script xmlns="">
			(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

			ga('create', 'UA-11694057-1', 'auto');
			ga('send', 'pageview');

		</script><script xmlns="" async="async">
			var _hmt = _hmt || [];
			(function() {
			var hm = document.createElement("script");
			hm.src = "https://hm.baidu.com/hm.js?93967759a51cda79e49bf4e34d0b0f2c";
			var s = document.getElementsByTagName("script")[0];
			s.parentNode.insertBefore(hm, s);
			})();
</script><script xmlns="" async="async">
			(function(){
			var bp = document.createElement('script');
			var curProtocol = window.location.protocol.split(':')[0];
			if (curProtocol === 'https') {
			bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
			}
			else {
			bp.src = 'http://push.zhanzhang.baidu.com/push.js';
			}
			var s = document.getElementsByTagName("script")[0];
			s.parentNode.insertBefore(bp, s);
			})();
</script></body></html>