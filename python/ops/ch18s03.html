<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>18.3.Â ç›‘è§†æ–‡ä»¶ç³»ç»Ÿ</title><link rel="stylesheet" type="text/css" href="../docbook.css" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><meta name="keywords" content="php,pear,pecl,phar, python, , " /><link rel="home" href="../index.html" title="Netkiller Python æ‰‹æœ­" /><link rel="up" href="index.html" title="ç¬¬Â 18Â ç« Â è‡ªåŠ¨åŒ–è¿ç»´" /><link rel="prev" href="é˜²ç«å¢™.html" title="18.2.Â Python å¼€å‘é˜²ç«å¢™" /><link rel="next" href="container.html" title="18.4.Â å®¹å™¨" /></head><body><a xmlns="" href="//www.netkiller.cn/">Home</a> |
		<a xmlns="" href="//netkiller.github.io/">ç®€ä½“ä¸­æ–‡</a> |
	    <a xmlns="" href="http://netkiller.sourceforge.net/">ç¹ä½“ä¸­æ–‡</a> |
	    <a xmlns="" href="/journal/index.html">æ‚æ–‡</a> |
	    <a xmlns="" href="https://zhuanlan.zhihu.com/netkiller">çŸ¥ä¹ä¸“æ </a> |
   	    <a xmlns="" href="https://edu.51cto.com/lecturer/1703915.html">51CTOå­¦é™¢</a> |
	    <a xmlns="" href="https://edu.csdn.net/lecturer/6423">CSDNç¨‹åºå‘˜ç ”ä¿®é™¢</a> |
	    <a xmlns="" href="https://github.com/netkiller">Github</a> |
	    <a xmlns="" href="http://my.oschina.net/neochen/">OSChina åšå®¢</a> |
	    <a xmlns="" href="https://cloud.tencent.com/developer/column/2078">è…¾è®¯äº‘ç¤¾åŒº</a> |
	    <a xmlns="" href="https://yq.aliyun.com/u/netkiller/">é˜¿é‡Œäº‘æ –ç¤¾åŒº</a> |
	    <a xmlns="" href="https://www.facebook.com/bg7nyt">Facebook</a> |
	    <a xmlns="" href="http://cn.linkedin.com/in/netkiller/">Linkedin</a> |
	    <a xmlns="" href="https://www.youtube.com/user/bg7nyt/videos">Youtube</a> |
	    <a xmlns="" href="//www.netkiller.cn/home/donations.html">æ‰“èµ(Donations)</a> |
	    <a xmlns="" href="//www.netkiller.cn/home/about.html">About</a><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">18.3.Â ç›‘è§†æ–‡ä»¶ç³»ç»Ÿ</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="é˜²ç«å¢™.html">ä¸Šä¸€é¡µ</a>Â </td><th width="60%" align="center">ç¬¬Â 18Â ç« Â è‡ªåŠ¨åŒ–è¿ç»´</th><td width="20%" align="right">Â <a accesskey="n" href="container.html">ä¸‹ä¸€é¡µ</a></td></tr></table><hr /></div><table xmlns=""><tr><td><iframe src="//ghbtns.com/github-btn.html?user=netkiller&amp;repo=netkiller.github.io&amp;type=watch&amp;count=true&amp;size=large" height="30" width="170" frameborder="0" scrolling="0" style="width:170px; height: 30px;" allowTransparency="true"></iframe></td><td><iframe src="//ghbtns.com/github-btn.html?user=netkiller&amp;repo=netkiller.github.io&amp;type=fork&amp;count=true&amp;size=large" height="30" width="170" frameborder="0" scrolling="0" style="width:170px; height: 30px;" allowTransparency="true"></iframe></td><td><iframe src="//ghbtns.com/github-btn.html?user=netkiller&amp;type=follow&amp;count=true&amp;size=large" height="30" width="240" frameborder="0" scrolling="0" style="width:240px; height: 30px;" allowTransparency="true"></iframe></td><td></td><td><a href="https://zhuanlan.zhihu.com/netkiller"><img src="/images/logo/zhihu-card-default.svg" height="25" /></a></td><td valign="middle"><a href="https://zhuanlan.zhihu.com/netkiller">çŸ¥ä¹ä¸“æ </a> ï½œ <a href="https://www.zhihu.com/club/1241768772601950208">å¤šç»´åº¦æ¶æ„</a></td><td></td><td></td><td></td><td></td></tr></table><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm20609241024"></a>18.3.Â ç›‘è§†æ–‡ä»¶ç³»ç»Ÿ</h2></div></div></div>
	
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm20609240384"></a>18.3.1.Â watchdog</h3></div></div></div>
		
		<p>watchdog æä¾›äº†æŒ‡å®šç›®å½•/æ–‡ä»¶çš„å˜åŒ–ç›‘æ§ï¼Œå¯¹äºæŒ‡å®šç›®å½•å†…çš„æ“ä½œï¼Œè¢«è§†ä¸ºä¸€æ¬¡äº‹ä»¶ã€‚å¦‚æ·»åŠ åˆ é™¤æ–‡ä»¶æˆ–ç›®å½•ã€é‡å‘½åæ–‡ä»¶æˆ–ç›®å½•ã€ä¿®æ”¹æ–‡ä»¶å†…å®¹ç­‰ï¼Œæ¯ç§å˜åŒ–éƒ½ä¼šè§¦å‘ä¸€æ¬¡äº‹ä»¶ï¼Œäº‹ä»¶æ˜¯ç”¨æˆ·å®šä¹‰çš„ä¸šåŠ¡é€»è¾‘ä»£ç ã€‚</p>
		<p>å®‰è£…</p>
		<pre class="screen">
			
pip install watchdog			
			
		</pre>
		<p>æ¼”ç¤ºç¨‹åº</p>
		<pre class="programlisting">
		
import sys
import time
import logging
from watchdog.observers import Observer
from watchdog.events import LoggingEventHandler

if __name__ == "__main__":

    path = r'/tmp'

    logging.basicConfig(level=logging.INFO,
                        format='%(asctime)s - %(message)s',
                        datefmt='%Y-%m-%d %H:%M:%S')
    event_handler = LoggingEventHandler()
    observer = Observer()
    observer.schedule(event_handler, path, recursive=True)
    observer.start()
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()
		
		</pre>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm20609237216"></a>18.3.1.1.Â Observer</h4></div></div></div>
			
			<pre class="programlisting">
			
# è®¾ç½®è¶…æ—¶æ—¶é—´		
watchdog.observers.Observer(timeout=30)			

# ç›‘æ§æŒ‡å®šè·¯å¾„pathï¼Œè¯¥è·¯å¾„è§¦å‘ä»»ä½•äº‹ä»¶éƒ½ä¼šè°ƒç”¨event_handleræ¥å¤„ç†ï¼Œå¦‚æœpathæ˜¯ç›®å½•ï¼Œrecursive=True å¼€å¯ä¼šé€’å½’æ¨¡å¼ï¼Œç›‘æ§è¯¥ç›®å½•ä¸‹çš„æ‰€æœ‰å˜åŒ–ã€‚
observer.schedule(event_handler, path, recursive=False)

# æ·»åŠ ä¸€ä¸ªäº‹ä»¶å¤„ç†å™¨åˆ°watchä¸­
observer.add_handler_for_watch(event_handler, watch)

# ä»watchä¸­ç§»é™¤ä¸€ä¸ªäº‹ä»¶å¤„ç†å™¨
observer.remove_handler_for_watch(event_handler, watch)

# ç§»é™¤ä¸€ä¸ªwatchåŠè¿™ä¸ªwatchä¸Šçš„æ‰€æœ‰äº‹ä»¶å¤„ç†å™¨
observer.unschedule(watch)

# ç§»é™¤æ‰€æœ‰watchåŠå…³è”çš„äº‹ä»¶å¤„ç†å™¨
observer.unschedule_all()
# ç­‰åŒäºobserver.unschedule_all()
observer.on_thread_stop()

# å¯åŠ¨ observer çº¿ç¨‹
observer.start()

# åœæ­¢observerçº¿ç¨‹
observer.stop()
			
			</pre>
			<div class="itemizedlist"><p class="title"><strong>Watchdog å‡ ç§ Observer ç±»å‹:</strong></p><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">InotifyObserverï¼ŒLinuxç³»ç»Ÿé»˜è®¤ä½¿ç”¨çš„è§‚å¯Ÿç›®å½•çš„è°ƒåº¦äº‹ä»¶ï¼Œæ•ˆç‡æ¯”è¾ƒé«˜ã€‚ </li><li class="listitem">PollingObserverï¼Œä¸å¹³å°æ— å…³ï¼Œè½®è¯¢ç›®å½•ä»¥æ£€æµ‹æ–‡ä»¶çš„æ›´æ”¹ï¼Œæ•ˆç‡æ¯”è¾ƒä½ã€‚</li><li class="listitem">WindowsApiObserverï¼ŒWindowsç³»ç»Ÿé»˜è®¤ä½¿ç”¨çš„è§‚å¯Ÿç›®å½•çš„è°ƒåº¦äº‹ä»¶ï¼Œæ•ˆç‡æ¯”è¾ƒé«˜ã€‚ </li><li class="listitem">FSEventsObserverï¼ŒmacOS ç³»ç»Ÿé»˜è®¤ä½¿ç”¨çš„è°ƒåº¦äº‹ä»¶</li><li class="listitem">KqueueObserverï¼ŒFreeBSD ç³»ç»Ÿé»˜è®¤ä½¿ç”¨</li></ul></div>
			<p>é»˜è®¤ Observer ä¼šåˆ¤æ–­æ“ä½œç³»ç»Ÿç±»å‹ï¼Œé€‰æ‹©æœ€ä½³çš„æ–¹å¼ã€‚ä¸‹é¢ğŸ‘‡æ˜¯ Observer çš„æºç </p>
			<pre class="programlisting">
			
# Linuxç³»ç»Ÿ
if platform.is_linux():
    try:
        from .inotify import InotifyObserver as Observer
    except UnsupportedLibc:
        from .polling import PollingObserver as Observer
# darwinç³»ç»Ÿ
elif platform.is_darwin():
    # FIXME: catching too broad. Error prone
    try:
        from .fsevents import FSEventsObserver as Observer
    except:
        try:
            from .kqueue import KqueueObserver as Observer
            warnings.warn("Failed to import fsevents. Fall back to kqueue")
        except:
            from .polling import PollingObserver as Observer
            warnings.warn("Failed to import fsevents and kqueue. Fall back to polling.")
# bsdç³»ç»Ÿ
elif platform.is_bsd():
    from .kqueue import KqueueObserver as Observer
# windowsç³»ç»Ÿ
elif platform.is_windows():
    # TODO: find a reliable way of checking Windows version and import
    # polling explicitly for Windows XP
    try:
        from .read_directory_changes import WindowsApiObserver as Observer
    except:
        from .polling import PollingObserver as Observer
        warnings.warn("Failed to import read_directory_changes. Fall back to polling.")

else:
    from .polling import PollingObserver as Observer		
			
			</pre>
			<p>æ‰‹å·¥é€‰æ‹© Observerï¼Œæ³¨æ„ä¸‹é¢ä»£ç  observer = PollingObserver()</p>
			<pre class="programlisting">
			
import sys
import time
import logging
# from watchdog.observers import Observer
from watchdog.observers.polling import PollingObserver
from watchdog.events import LoggingEventHandler

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO,
                        format='%(asctime)s - %(message)s',
                        datefmt='%Y-%m-%d %H:%M:%S')
    path = sys.argv[1] if len(sys.argv) &gt; 1 else '.'
    event_handler = LoggingEventHandler()
    observer = PollingObserver()
    observer.schedule(event_handler, path, recursive=True)
    observer.start()
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm20609230032"></a>18.3.1.2.Â åˆ›å»º/åˆ é™¤/ä¿®æ”¹/ç§»åŠ¨</h4></div></div></div>
			
			<p>å®šä¹‰åˆ›å»º/åˆ é™¤/ä¿®æ”¹/ç§»åŠ¨å››ç§äº‹ä»¶</p>
			<pre class="programlisting">
			
from watchdog.observers import Observer
from watchdog.events import *
import time


class DemoFileSystemEventHandler(FileSystemEventHandler):

    def __init__(self):
        FileSystemEventHandler.__init__(self)

    def on_moved(self, event):
        if event.is_directory:
            print("directory moved from {0} to {1}".format(
                event.src_path, event.dest_path))
        else:
            print("file moved from {0} to {1}".format(
                event.src_path, event.dest_path))

    def on_created(self, event):
        if event.is_directory:
            print("directory created:{0}".format(event.src_path))
        else:
            print("file created:{0}".format(event.src_path))

    def on_deleted(self, event):
        if event.is_directory:
            print("directory deleted:{0}".format(event.src_path))
        else:
            print("file deleted:{0}".format(event.src_path))

    def on_modified(self, event):
        if event.is_directory:
            print("directory modified:{0}".format(event.src_path))
        else:
            print("file modified:{0}".format(event.src_path))


if __name__ == "__main__":

    path = r'/tmp'

    observer = Observer()
    event_handler = DemoFileSystemEventHandler()
    observer.schedule(event_handler, path, recursive=True)
    observer.start()
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()
			
			
			</pre>
			<p>on_any_event ä»»ä½•äº‹ä»¶éƒ½ä¼šè§¦å‘</p>
			<pre class="programlisting">
			
import time
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler


class MyHandler(FileSystemEventHandler):
    def on_any_event(self, event):
        if event.is_directory:
            print('Directory', event.event_type, event.src_path)
        else:
            print('File', event.event_type, event.src_path)


if __name__ == "__main__":

    monitor_path = '/tmp'

    event_handler = MyHandler()
    observer = Observer()
    observer.schedule(event_handler, path=monitor_path, recursive=True)
    observer.start()
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()
			
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm20609226976"></a>18.3.1.3.Â å¤šäº‹ä»¶ç»‘å®š</h4></div></div></div>
			
			<pre class="programlisting">
			
import time
import logging
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
from watchdog.events import LoggingEventHandler


class MyEventHandler(FileSystemEventHandler):
    def on_any_event(self, event):
        if event.is_directory:
            print('Directory', event.event_type, event.src_path)
        else:
            print('File', event.event_type, event.src_path)


if __name__ == "__main__":

    watch_path = '/tmp'

    logging.basicConfig(level=logging.INFO,
                        format='%(asctime)s - %(message)s',
                        datefmt='%Y-%m-%d %H:%M:%S')
    loggingEventHandler = LoggingEventHandler()
    myEventHandler = MyEventHandler()

    observer = Observer()

    watch1 = observer.schedule(
        loggingEventHandler, path=watch_path, recursive=True)
    watch2 = observer.schedule(
        myEventHandler, path=watch_path, recursive=True)

    observer.add_handler_for_watch(loggingEventHandler, watch1)
    observer.add_handler_for_watch(myEventHandler, watch2)

    observer.start()
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()
			
			
			</pre>
		</div>
		
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm20609225040"></a>18.3.1.4.Â è‡ªåŠ¨å¤‡ä»½ç¨‹åº</h4></div></div></div>
			
			<p>äº‹æƒ…çš„ èµ·å›  - ç»è¿‡ - ç»“æœ</p>
			<p>åšè§†é¢‘å‰ªè¾‘æœ‰ä¸€æ®µæ—¶é—´äº†ï¼Œè‹¹æœç¬”è®°æœ¬ç”µè„‘ç¡¬ç›˜æ¯”è¾ƒå°ï¼Œè§†é¢‘å‰ªè¾‘ç©ºé—´ä¸å¤Ÿï¼Œæ‰€ä»¥å¿…é¡»å¤–æŒ‚ä¸€ä¸ªå‰ªè¾‘ç›˜ã€‚</p>
			<p>æˆ‘ä½¿ç”¨äº†ç”±ä¸¤å— SSD ç»„æˆçš„ RAID ç¡¬ç›˜ç›’å­ï¼Œèµ·åˆæ˜¯è¿½æ±‚é€Ÿåº¦å¿«ï¼Œä½¿ç”¨ RAID 0 æ¨¡å¼ï¼ŒåæœŸä¸ºäº†å®‰å…¨ åˆ‡æ¢åˆ°äº† RAID 1 æ¨¡å¼ã€‚è¿™æ ·ç¡¬ä»¶çš„å®‰å…¨å°±è§£å†³äº†ï¼Œå†ä¹Ÿä¸ç”¨æ‹…å¿ƒç¡¬ç›˜æŸåæ•°æ®ä¸¢å¤±äº†ã€‚</p>
			<p>æŸä¸€å¤©ï¼Œå°±å¦‚æ—¥å¸¸å‰ªè¾‘ä¸€æ ·ï¼Œå½“æˆ‘è¯•å›¾æ‰“å¼€ Final cut pro èµ„æºåº“çš„æ—¶å€™ï¼Œæ‚²å‰§äº†ï¼ï¼ï¼</p>
			<p>Fcpx çš„å·¥ç¨‹æ–‡ä»¶æ‰“ä¸å¼€äº†ï¼Œé—ªé€€åæç¤ºé”™è¯¯ï¼Œè¿™æ¬¡ç¿»è½¦ä¸¢å¤±äº†ã€ŠNetkiller Architect æ‰‹æœ­ã€‹6ä¸ªè§†é¢‘ï¼Œä¸è¿‡è¿˜å¥½ï¼Œé‚£äº›è§†é¢‘éƒ½æ˜¯åˆæœŸåšå“ï¼Œå½•åˆ¶å’Œå‰ªè¾‘éƒ½ä¸ç®—å¥½ï¼Œæœ¬å°±æœ‰é‡åšçš„æƒ³æ³•ã€‚</p>
			<p>è¿™æ¬¡ç»å†è®©æˆ‘ä¸åœ¨ç›¸ä¿¡ fcpx çš„èµ„æºåº“ç®¡ç†èƒ½åŠ›ï¼Œé¸¡è›‹æ”¾åœ¨ä¸€ä¸ªç¯®å­é‡ŒåŠå…¶å±é™©çš„ï¼Œã€ŠNetkiller Python æ‰‹æœ­ã€‹æˆ‘æŠŠä¸€ç« å†…å®¹æ”¾åœ¨ä¸€ä¸ªèµ„æºåº“ä¸­ï¼Œæ¯èŠ‚ä¸€ä¸ªäº‹ä»¶ã€‚</p>
			<p>ä¹‹å‰ä¹Ÿå¶å°”å¤‡ä»½ï¼Œæ‰‹å·¥å¤åˆ¶ï¼Œæœ‰æ—¶æ¯”è¾ƒæ‡’ï¼Œå°±æ²¡æœ‰å¤‡ä»½ã€‚äºæ˜¯æˆ‘ä¾¿å†™äº†ä¸€ä¸ªç¨‹åºï¼Œæ¥è‡ªåŠ¨å¤‡ä»½è§†é¢‘å‰ªè¾‘ç›˜ã€‚</p>
			<div class="itemizedlist"><p class="title"><strong>å®ç°åŠŸèƒ½ï¼š</strong></p><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">æ’å…¥Uè®¾å¤‡ï¼Œå‘ç°ç§»åŠ¨ç¡¬ç›˜</li><li class="listitem">å‰ªè¾‘ç›˜å’Œå¤‡ä»½ç›˜æ²¡æœ‰å…¶ä»–ç¨‹åºå ç”¨</li><li class="listitem">å¼€å§‹å¤‡ä»½</li><li class="listitem">å¤‡ä»½å®Œæˆåè‡ªåŠ¨å¼¹å‡ºç§»åŠ¨è®¾å¤‡</li></ul></div>

			<pre class="programlisting">
			
#!/usr/bin/python3
# -*- coding: UTF-8 -*-
# ================================================================================
# è§†é¢‘å‰ªè¾‘ç›˜è‡ªåŠ¨å¤‡ä»½ç¨‹åº
# ä½œè€…: netkiller | netkiller@msn.com | http://www.netkiller.cn
# ================================================================================

import time
import os
import signal
import sys
import atexit
import subprocess
# from atexit import register
from watchdog.observers import Observer
from watchdog.events import *


class FileEventHandler(FileSystemEventHandler):
    src_path = ''
    dst_path = ''
    watchpath = {}

    def __init__(self, logger, watchpath):
        FileSystemEventHandler.__init__(self)
        self.watchpath = watchpath
        self.logger = logger

    def execute(self, cmd):
        fr = os.popen(cmd)
        # text = fr.read()
        text = fr.readlines()
        fr.close()
        # print(len(text), text)
        return(text)

    def isBusy(self, path):
        cmd = "lsof {}".format(path)
        # print(cmd)
        if len(self.execute(cmd)) == 0:
            self.logger.info("ç›®å½•ç©ºé—²: {0}".format(path))
            return False
        else:
            self.logger.info("ç›®å½•ç¹å¿™: {0}".format(path))
            return True

    def mirror(self):
        self.logger.info("å¼€å§‹å¤‡ä»½")
        cmd = "/usr/bin/rsync -auzv --delete --exclude=.Spotlight-V100 --exclude=.fseventsd {0} {1}".format(
            self.src_path, self.dst_path)
        # self.logger.info(cmd)

        sp = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
        for line in iter(sp.stdout.readline, b''):
            self.logger.info(line.decode('UTF8').replace("\n", ''))
        sp.stdout.close()
        sp.wait()
        self.logger.info("å¤‡ä»½å®Œæˆ")

    def umount(self):
        if not self.isBusy(self.src_path):
            self.logger.info("å¸è½½ç§»åŠ¨ç¡¬ç›˜")
            os.system("diskutil eject {0}".format(
                os.path.basename(self.src_path)))
        else:
            self.logger.info("ç§»åŠ¨ç¡¬ç›˜ {0} ç¹å¿™".format(self.src_path))

    def backup(self):
        if not os.path.exists(self.dst_path):
            os.mkdir(self.dst_path)
        if not self.isBusy(self.src_path):
            if not self.isBusy(self.dst_path):
                self.mirror()
                time.sleep(5)
                self.umount()

    def on_created(self, event):
        if event.is_directory:
            self.logger.info("å‘ç°ç§»åŠ¨ç¡¬ç›˜:{0}".format(event.src_path))
            # self.path = self.watchpath[event.src_path]
            self.src_path = event.src_path
            self.dst_path = self.watchpath[event.src_path]
            self.backup()

    def on_deleted(self, event):
        if event.is_directory:
            self.logger.info("å¸è½½ç§»åŠ¨ç¡¬ç›˜: {0}".format(event.src_path))


class Backup():

    pidfile = "/tmp/netkiller.pid"
    logdir = "/tmp"
    logfile = logdir+"/netkiller.log"
    logger = None
    loop = True
    job = True

    watchpath = {'/Volumes/Video': '/tmp/Backup',
                 '/Volumes/Photo': '/tmp/Backup'}

    observer = Observer()

    def __init__(self):
        logging.basicConfig(level=logging.NOTSET,
                            format='%(asctime)s %(levelname)-8s %(message)s',
                            datefmt='%Y-%m-%d %H:%M:%S',
                            filename=self.logfile,
                            filemode='a')
        self.logger = logging.getLogger()

    # ä¿å­˜è¿›ç¨‹ID
    def savepid(self, pid):
        with open(self.pidfile, 'w') as f:
            f.write(str(os.getpid()))
        # æ³¨å†Œé€€å‡ºå‡½æ•°ï¼Œè¿›ç¨‹é€€å‡ºæ—¶è‡ªåŠ¨ç§»é™¤pidfileæ–‡ä»¶
        atexit.register(os.remove, self.pidfile)

    # ä»pidfileä¸­è¯»å–è¿›ç¨‹ID
    def getpid(self):
        pid = 0
        try:
            with open(self.pidfile, 'r') as f:
                pid = int(f.readline())
        except FileNotFoundError as identifier:
            print(identifier)
        return pid

    # ä¿¡å·å¤„ç†
    def signalHandler(self, signum, frame):
        # global loop, job
        # print("SIGN ",str(signum));
        if signum == signal.SIGHUP:
            # ä¼˜é›…é‡å¯
            self.job = False
            self.logger.info("ä¼˜é›…é‡å¯å®Œæ¯•")
        elif signum == signal.SIGINT:
            # æ­£å¸¸é€€å‡º
            self.loop = False
            self.job = False
            self.observer.stop()
            self.logger.info("æ­£å¸¸é€€å‡º")
        elif signum == signal.SIGUSR1:
            # æ—¥å¿—åˆ‡å‰²
            pass

    def daemonize(self):
        # global job
        self.logger.info("å¯åŠ¨å®ˆæŠ¤è¿›ç¨‹")
        signal.signal(signal.SIGHUP, self.signalHandler)
        signal.signal(signal.SIGINT, self.signalHandler)
        signal.signal(signal.SIGUSR1, self.signalHandler)
        signal.alarm(5)

        pid = os.fork()
        sys.stdout.flush()
        sys.stderr.flush()
        if pid:
            sys.exit(0)
        # print(os.getpid())
        self.savepid(str(os.getpid()))
        while self.loop:
            self.logger.info("Start!!!")
            self.main()
            self.logger.info("Exit!!!")

    def start(self):
        if os.path.isfile(self.pidfile):
            print("ç¨‹åºå·²ç»å¯åŠ¨")
            sys.exit(1)
        else:
            self.daemonize()

    def stop(self):
        try:
            os.kill(self.getpid(), signal.SIGINT)
        except ProcessLookupError as identifier:
            print(identifier)

    def reloads(self):
        try:
            os.kill(self.getpid(), signal.SIGHUP)
        except ProcessLookupError as identifier:
            print(identifier)

    def logrotate(self):
        try:
            os.kill(self.getpid(), signal.SIGUSR1)
        except ProcessLookupError as identifier:
            print(identifier)

    def main(self):
        # ä¸šåŠ¡é€»è¾‘
        event_handler = FileEventHandler(self.logger, self.watchpath)
        for src, dst in self.watchpath.items():
            self.logger.info("ç›‘æ§ {0} =&gt; {1}".format(src, dst))
            self.observer.schedule(
                event_handler, path=src, recursive=False)
        self.logger.info("å¯åŠ¨ Watchdog")
        self.observer.start()
        self.observer.join()
        # ä¸šåŠ¡é€»è¾‘


def usage():
    print(sys.argv[0] + " start | stop | restart | reload | log")


if __name__ == "__main__":
    # print(sys.argv)
    backup = Backup()
    if len(sys.argv) &gt; 1:
        arg = sys.argv[1]
        if arg == "start":
            backup.start()
        elif arg == "stop":
            backup.stop()
        elif arg == "restart":
            backup.stop()
            backup.start()
        elif arg == "reload":
            backup.reloads()
        else:
            usage()
    else:
        usage()
			
			
			</pre>
		</div>
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm20609240256"></a>18.3.2.Â pyinotify</h3></div></div></div>
		
	</div>
</div><div xmlns="" id="SOHUCS"></div><script xmlns="" charset="utf-8" type="text/javascript" src="https://cy-cdn.kuaizhan.com/upload/changyan.js"></script><script xmlns="" type="text/javascript">
window.changyan.api.config({
appid: 'cyvwjQUG3',
conf: 'prod_ef966242df3d8b5acb1e0ee9fc01cafe'
});
</script><script xmlns="" type="text/javascript" id="clustrmaps" src="//cdn.clustrmaps.com/map_v2.js?u=r5HG&amp;d=9mi5r_kkDC8uxG8HuY3p4-2qgeeVypAK9vMD-2P6BYM"></script><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="é˜²ç«å¢™.html">ä¸Šä¸€é¡µ</a>Â </td><td width="20%" align="center"><a accesskey="u" href="index.html">ä¸Šä¸€çº§</a></td><td width="40%" align="right">Â <a accesskey="n" href="container.html">ä¸‹ä¸€é¡µ</a></td></tr><tr><td width="40%" align="left" valign="top">18.2.Â Python å¼€å‘é˜²ç«å¢™Â </td><td width="20%" align="center"><a accesskey="h" href="../index.html">èµ·å§‹é¡µ</a></td><td width="40%" align="right" valign="top">Â 18.4.Â å®¹å™¨</td></tr></table></div><script xmlns="">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-11694057-1', 'auto');
  ga('send', 'pageview');

</script><script xmlns="" async="async">
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?93967759a51cda79e49bf4e34d0b0f2c";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script xmlns="" async="async">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script></body></html>